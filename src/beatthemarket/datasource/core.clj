(ns beatthemarket.datasource.core
  (:require [random-seed.core :refer :all])
  (:refer-clojure :exclude [rand rand-int rand-nth])
  (:import [org.apache.commons.math3.distribution BetaDistribution]
           [org.apache.commons.math3.random RandomGeneratorFactory]
           [java.util Random]))


;; >> ================================ >>

(def beta-configurations
  "Get an intuition for the probability curves, generated by these alpha / beta curves
   https://en.wikipedia.org/wiki/Beta_distribution"

  {:bigswings {:alpha 0.5 :beta 0.5}
   :midpoint  {:alpha 2.0 :beta 2.0}

   :left-leaning {:alpha 2.0 :beta 5.0}

   :highend {:alpha 3.0 :beta 1.0}
   :lowend  {:alpha 1.0 :beta 3.0}

   :alternating-price-changes {:alpha 3.0 :beta 2.65}})


(defn random-seed

  ([] (random-seed 10000000))

  ([upper-bound]
   (clojure.core/rand-int upper-bound)))

(defn ->beta-distribution

  ([alpha beta]
   (->beta-distribution (random-seed 10000000) alpha beta))

  ([seed alpha beta]

   (let [rng (RandomGeneratorFactory/createRandomGenerator (Random. seed))]
     (BetaDistribution. rng alpha beta))))


;; >> ================================ >>


(defn random-double-in-range
  "Returns a random double between min and max.

   stolen from lazytest - no longer under active development
   https://github.com/stuartsierra/lazytest/blob/master/modules/lazytest/src/main/clojure/lazytest/random.clj"

  ([min max]
   (random-double-in-range (random-seed) min max))

  ([seed min max]
   {:pre [(<= min max)]}

   (set-random-seed! seed)
   (+ min (* (- max min) (rand)))))


;; >> ================================ >>

#_(defn randomize-vertical-dilation
    "vertical dilation (or amplitude)
     polynomial: 2 - 0.5
     sine: 0.5 - 2.7"
    [mathfn min' max']
    (let [a (random-double-in-range min' max')]
      (partial mathfn a)))

#_(defn randomize-horizontal-dilation
    "horizontal dilation
     polynomial: between 2 - 0.5 (larger b yields a narrower curve)
     sine: 2.7 - 0.3"
    [mathfn-curried min' max']
    (let [b (random-double-in-range min' max')]
      (partial mathfn-curried b)))

;; >> ================================ >>

(defn ydirection [ypos]
  (if (pos? ypos)
    :positive
    :negative))

(defn direction-changed? [ypos dirn]
  (not= (ydirection ypos) dirn))

(defn get-opposite-direction-key [ydir]
  (if (= ydir :positive)
    :negative
    :positive))

(defn get-opposite-direction-fn [dirn]
  (if (= dirn +) - +))

(defn effectively-zero? [xval]
  (= 0.0 (Float. (format "%.7f" xval))))

(defn find-xintercept [direction mfn]

  ;; find initial direction of y (take y at 0.1 of x=0)
  ;; step 1 in given direction until we pass through x
  (loop [start-point 0.0
         distance    1.0
         ydir        (ydirection (mfn (direction 0 0.1)))
         dirn        direction]

    (let [next-point (dirn start-point distance)]

      (if (effectively-zero? (mfn next-point))

        next-point

        (let [dc? (direction-changed? (mfn next-point) ydir)]

          ;; (println (str "start[" start-point "] / end[" next-point "] / direction-changed?[" dc? "] / Y[" (mfn next-point) "]"))
          ;; divide that step in half and go the other direction, until we again pass through x
          ;; repeat until we have a zero up to the 7th digit
          (recur next-point
                 (if dc? (/ distance 2) distance)
                 (if dc? (get-opposite-direction-key ydir) ydir)
                 (if dc? (get-opposite-direction-fn dirn) dirn)))))))

(comment

  ;; phases - figuring out x intercepts
  ;; repeatable
  ;;   mark phase start / end
  ;; => randomize phase entry point
  ;; => randomize sample length of phase (between 50% - 100%)

  ;; find x-intercepts both left and right from x=0.
  (find-xintercept - polynomial-xintercept)
  -1.8228756561875343

  (find-xintercept + polynomial-xintercept)
  0.8228756487369537

  (find-xintercept - sine-xintercept)
  -1.570796325802803

  (find-xintercept + sine-xintercept)
  1.570796325802803)
